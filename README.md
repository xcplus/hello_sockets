# WebSocket 链接请求流程：
curl -i "http://localhost:4000/socket/websocket?vsn=2.0.0"
1. 向WebSocket端点发起GET HTTP（S）连接请求
2. 从服务器接收到101或错误
3. 如果收到101，则将协议升级到WebSocket
4. 通过WebSocket连接发送/接收帧

注：客户端管理心跳而不是服务器，这很有用。 如果客户端的ping请求检测到连接问题，则客户端可以快速尝试重新连接并重新建立连接。 如果服务器负责向客户端发送ping，则服务器知道连接问题，但无法与客户端建立新连接。 这会使客户处于较长时间的脱节状态。

# 长轮询
--- HTTP长轮询[17]是一种使用标准HTTP以便将数据异步发送到客户端的技术。 这符合可以发送（长轮询响应）和从客户端接收（客户端请求）数据的实时通信层的要求。 长轮询是WebSockets最常用的前身，比它早几年。 这意味着该技术尽管有缺点，却非常稳定。

长轮询的请求流程：
1. 客户端向服务器发起HTTP请求。
2. 服务器不响应请求，而是保持打开状态。 服务器收到新数据或时间过长时将做出响应。
3. 服务器将完整的响应发送给客户端。 此时，客户端知道了来自服务器的实时数据。
4. 只要需要实时通信，客户端就会循环此流程。

长轮询流程的关键部分是，客户端与服务器的连接将保持打开状态，直到收到新数据为止。 这样一来，数据就可以立即推送到连接的客户端。 长轮询是一种用于实时通信的可行技术，但是它面临的挑战使WebSockets显然是我们应用程序的更好选择。

### 长轮询的缺点
1. 每个长轮询请求都会处理请求标头。 这可能会大大增加服务器需要处理的传输字节数。 这并非最佳效果
2. 当使用不良网络时，消息延迟可能会很高。 丢弃的数据包和数据传输时间会使延迟大大增加，因为必须重新建立多个连接才能重新建立长轮询连接。 这会影响应用程序的实时感。

### 长轮询的优点
1. 长轮询连接可以在多个服务器之间轻松实现负载平衡，因为经常建立连接。如果连接寿命长，WebSockets可能很难进行负载平衡，因为不会发生重新连接以更改客户端连接到哪个服务器。
2. 可以透明地利用协议的改进，例如HTTP的未来版本。 Google是互联网协议的创新者，它利用一种长期轮询的自定义形式来为某些实时应用程序提供支持。

# Phoenix
```
                                                                  +----------------+
                                                     +--Topic X-->| Mobile Client  |
                                                     |            +----------------+
                              +-------------------+  |
+----------------+            |                   |  |            +----------------+
| Browser Client |--Topic X-->| Phoenix Server(s) |--+--Topic X-->| Desktop Client |
+----------------+            |                   |  |            +----------------+
                              +-------------------+  |
                                                     |            +----------------+
                                                     +--Topic X-->|   IoT Client   |
                                                                  +----------------+
```

# Phoenix Channels

客户端通过直接连接到管理连接的OTP进程，通过WebSocket等传输机制连接到服务器。 此过程将某些操作（例如，接受还是拒绝连接请求）委派给实现Phoenix.Socket行为的应用程序代码。

使用Phoenix.Socket的模块可以将客户端请求的主题路由到提供的Phoenix.Channel实现模块。 Channel模块针对用户连接到的每个不同主题启动一个单独的进程。 Channel像传输进程一样，永远不会在不同的连接之间共享。

```
----------------         -----------------       ---------------------------
|client request|   --->  | Phoenix.Socket|  -->  |扩展了Phoenix.Channel的模块| 
----------------         -----------------       ---------------------------

    -------------
--> |  process  |
    -------------
```

### Sockets

Sockets 构成了Phoenix实时通信的基础。 Socket是实现Phoenix.Socket.Transport行为的模块，但是我们将使用称为Phoenix.Socket的特定实现。 您很可能会在应用程序中使用Phoenix.Socket，因为它以遵循最佳实践的方式实现了WebSocket和长轮询。 （如果您需要一个罕见的自定义传输层，那么您确实可以实现自己的Socket.Transport。）

我们只需要实现一些功能即可创建功能性的Socket实现, 回调函数connect/3和id/1提供了我们应用程序套接字的模板。

connect/3 可以用于认证用户
id/1 识别当前链接的客户端,用于追踪Socket或者想要断开链接

### Channels

是我们应用程序逻辑的实时入口点，并且是大多数应用程序的请求处理代码所在的位置。 Channel具有多种职责来启用实时应用程序：

1. 接受或拒绝加入请求
2. 处理来自客户端的消息
3. 处理来自PubSub的消息
4. 将消息推送到客户端

Socket 的职责包括连接处理和将请求路由到正确的 Channel。 Channel 的职责涉及处理来自客户的请求并将数据发送到客户。 Channel 类似于MVC（模型-视图-控制器）设计模式中的控制器


### Topics
是字符串标识符，当套接字接收到“phx_join”消息时，该标识符用于连接到正确的Channel。 它们是在Socket模块中定义的，就像我们之前在UserSocket示例中看到的那样。


### PubSub
Phoenix.PubSub（发布者/订阅者）在我们的实时应用程序中为Topic订阅和消息广播提供支持。 Channel在内部使用PubSub，因此我们很少会直接与其进行交互。 但是，了解PubSub很有用，因为我们需要为我们的应用程序正确配置它，以确保性能和通信可用性。

PubSub链接在本地节点和所有连接的远程节点之间。 这使PubSub可以在整个群集中广播消息。 当客户端处于连接到群集节点A的消息来自群集节点B的情况下，远程消息广播非常重要。 PubSub开箱即用为我们处理此问题，但我们确实需要确保节点之间可以互相通信。 PubSub随附了pg2适配器。 还有一个Redis PubSub适配器，它允许使用PubSub而无需将节点群集在一起。

当我们调用HelloSocketsWeb.Endpoint.broadcast / 3函数时，将使用PubSub

# 发送和接受消息

### Phoenix 的消息结构

+ Join Ref - 唯一的字符串，与客户端连接到Channel时提供的内容匹配。 这用于帮助防止来自客户端的重复频道订阅。 实际上，这个数字在每次加入频道时都会增加
+ Message Ref - 客户端在每条消息上提供的唯一字符串。 这用于允许发送答复以响应客户消息。 实际上，这是一个数字，每当客户发送一条消息时，该数字就会增加
+ Topic - Channel 对应的 Topic
+ Event - 标识消息的字符串， Channel 实现可以使用模式匹配轻松处理不同事件
+ Payload - 一个 JSON 编码的映射（字符串），包含消息的数据内容。 Channel 实现可以在解码后的Map上使用模式匹配来处理事件的不同情况

### 接受来自客户端的消息

当客户将消息发送到Channel时，传输过程会接收到该消息并将其委托给Socket的handle_in/2回调。 Socket将解码的Message结构发送到正确的Channel进程，并处理任何错误，例如Topic不匹配。 Phoenix.Channel.Server进程通过委派给关联的Channel实现的handle_in/3回调来处理发送的消息。 这对我们来说是透明的，这意味着我们只需要关心客户端发送消息以及我们Channel的handle_in/3回调处理消息。

### 其他响应类型

我们还有其他方法可以处理传入事件，而不是回复客户({:reply, payload, socket} | {:reply, socket})。 让我们看一下两种不同的回应方式：什么都不做({:noreply, socket})或停止频道({:stop, :shutdown, {:ok, %{....}}, socket})。

### 发送消息到客户端

如果不需要自定义有效负载，则最好不要编写拦截事件，因为每个推送的消息将由其自身进行编码，每个订阅的Channel最多编码一次，而不是一次推送到所有订阅的Channel。 这将降低具有许多订户的系统的性能。

# Channel 客户端(频道客户端)

### 官方Javascirpt客户端

任何Channel客户都有一些关键职责，为了使所有行为都能按预期进行，应遵循以下几个关键职责：
- 连接到服务器并使用心跳保持连接
- 加入请求的Topic
- 将消息推送到Topic并可以选择处理响应
- 接收来自Topic的消息
- 妥善处理断开连接和其他错误； 尝试尽可能保持连接

